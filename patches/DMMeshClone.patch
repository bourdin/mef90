diff --git a/include/petscdmmesh.h b/include/petscdmmesh.h
--- a/include/petscdmmesh.h
+++ b/include/petscdmmesh.h
@@ -37,6 +37,7 @@ PETSC_EXTERN PetscLogEvent DMMesh_View, 
 
 PETSC_EXTERN PetscErrorCode DMMeshCreate(MPI_Comm, DM*);
 PETSC_EXTERN PetscErrorCode DMMeshCreateMeshFromAdjacency(MPI_Comm, PetscInt, PetscInt, PetscInt, PetscInt [], PetscInt, PetscInt, const PetscReal [], PetscBool, DM*);
+PETSC_EXTERN PetscErrorCode DMMeshClone(DM, DM *);
 PETSC_EXTERN PetscErrorCode DMMeshGetMesh(DM, ALE::Obj<PETSC_MESH_TYPE>&);
 PETSC_EXTERN PetscErrorCode DMMeshSetMesh(DM, const ALE::Obj<PETSC_MESH_TYPE>&);
 PETSC_EXTERN PetscErrorCode DMMeshGetGlobalScatter(DM, VecScatter *);
diff --git a/include/sieve/Mesh.hh b/include/sieve/Mesh.hh
--- a/include/sieve/Mesh.hh
+++ b/include/sieve/Mesh.hh
@@ -1699,6 +1699,21 @@
     };
     int getMaxDof() const {return this->_maxDof;};
     void setMaxDof(const int maxDof) {this->_maxDof = maxDof;};
+    void copy(const Obj<IMesh>& m) {
+      this->setSieve(m->getSieve());
+      this->_calculatedOverlap = m->_calculatedOverlap;
+      this->_sendOverlap       = m->_sendOverlap;
+      this->_recvOverlap       = m->_recvOverlap;
+      const labels_type& labels = m->getLabels();
+
+      for(typename labels_type::const_iterator l_iter = labels.begin(); l_iter != labels.end(); ++l_iter) {
+        this->setLabel(l_iter->first, l_iter->second);
+      }
+      this->_maxHeight = m->height();
+      this->_maxDepth  = m->depth();
+      this->setRealSection("coordinates", m->getRealSection("coordinates"));
+      this->setArrowSection("orientation", m->getArrowSection("orientation"));
+    };
   public: // Sizes
     template<typename Section>
     int size(const Obj<Section>& section, const point_type& p) {
@@ -2803,7 +2815,9 @@ namespace ALE {
       this->_maxHeight = m->height();
       this->setLabel("depth", m->getLabel("depth"));
       this->_maxDepth  = m->depth();
-      this->setLabel("marker", m->getLabel("marker"));
+      if (m->hasLabel("marker")) {
+        this->setLabel("marker", m->getLabel("marker"));
+      }
       this->setRealSection("coordinates", m->getRealSection("coordinates"));
       this->setArrowSection("orientation", m->getArrowSection("orientation"));
     };
diff --git a/src/dm/impls/mesh/mesh.c b/src/dm/impls/mesh/mesh.c
--- a/src/dm/impls/mesh/mesh.c
+++ b/src/dm/impls/mesh/mesh.c
@@ -4509,3 +4509,40 @@ inline void ExpandInterval_New(ALE::Poin
     indices[(*indx)++] = -1;
   }
 }
+
+#undef __FUNCT__
+#define __FUNCT__ "DMMeshClone"
+/*@
+  DMMeshClone - Creates a DMMesh object with the same mesh as the original.
+
+  Collective on MPI_Comm
+
+  Input Parameter:
+. dm - The original DMMesh object
+
+  Output Parameter:
+. newdm  - The new DMMesh object
+
+  Level: beginner
+
+.keywords: DMMesh, create
+@*/
+PetscErrorCode DMMeshClone(DM dm, DM *newdm)
+{
+  ALE::Obj<PETSC_MESH_TYPE> m;
+  void          *ctx;
+  PetscErrorCode ierr;
+
+  PetscFunctionBegin;
+  PetscValidHeaderSpecific(dm, DM_CLASSID, 1);
+  PetscValidPointer(newdm,2);
+  ierr = DMCreate(((PetscObject) dm)->comm, newdm);CHKERRQ(ierr);
+  ierr = DMSetType(*newdm, DMMESH);CHKERRQ(ierr);
+  ierr = DMMeshGetMesh(dm, m);CHKERRQ(ierr);
+  ALE::Obj<PETSC_MESH_TYPE> newm = new PETSC_MESH_TYPE(m->comm(), m->getDimension(), m->debug());
+  newm->copy(m);
+  ierr = DMMeshSetMesh(*newdm, newm);CHKERRQ(ierr);
+  ierr = DMGetApplicationContext(dm, &ctx);CHKERRQ(ierr);
+  ierr = DMSetApplicationContext(*newdm, ctx);CHKERRQ(ierr);
+  PetscFunctionReturn(0);
+}
