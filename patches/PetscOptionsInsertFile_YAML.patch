diff -r 93f374d090c4 src/sys/examples/tutorials/ex79.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/sys/examples/tutorials/ex79.c	Mon Jul 30 15:35:58 2012 -0500
@@ -0,0 +1,19 @@
+static char help[] = "Example for PetscOptionInsertFile_YAML\n";
+#include <petscsys.h>
+
+int main(int argc,char **argv)
+{
+  PetscErrorCode  ierr;
+  char            filename[PETSC_MAX_PATH_LEN];
+  PetscBool       flg;
+
+  PetscInitialize(&argc,&argv,(char *)0,help);
+  ierr = PetscOptionsGetString(PETSC_NULL,"-f",filename,sizeof filename,&flg);
+  if (flg) {
+    ierr = PetscOptionsInsertFile_YAML(PETSC_COMM_WORLD,filename,PETSC_TRUE);CHKERRQ(ierr);
+  }
+  ierr = PetscOptionsView(PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
+  ierr = PetscFinalize();
+  return(0);
+}
+
diff -r 93f374d090c4 src/sys/examples/tutorials/ex79f90.F90
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/sys/examples/tutorials/ex79f90.F90	Mon Jul 30 15:35:58 2012 -0500
@@ -0,0 +1,19 @@
+      program ex79f90
+#include "finclude/petscdef.h"
+      use petsc
+      implicit none
+   
+      PetscErrorCode                            :: ierr
+      Character(len=256)                        :: filename
+      PetscBool                                 :: flg
+      
+      Call PetscInitialize(PETSC_NULL_CHARACTER,ierr)
+      call PetscOptionsGetString(PETSC_NULL_CHARACTER,"-f",filename,flg,ierr)
+      if (flg) then
+         call PetscOptionsInsertFile_YAML(PETSC_COMM_WORLD,filename,PETSC_TRUE,ierr);
+      end if
+      call PetscOptionsView(PETSC_VIEWER_STDOUT_WORLD,ierr)
+      Call PetscFinalize(ierr)
+      end program ex79f90
+
+
diff -r 93f374d090c4 src/sys/examples/tutorials/makefile
--- a/src/sys/examples/tutorials/makefile	Sat Jul 28 11:35:56 2012 -0500
+++ b/src/sys/examples/tutorials/makefile	Mon Jul 30 15:35:58 2012 -0500
@@ -61,6 +61,15 @@ ex7: ex7.o   chkopts
 ex8f90: ex8f90.o  chkopts
 	-${FLINKER} -o ex8f90 ex8f90.o ${PETSC_SYS_LIB}
 	${RM} ex8f90.o
+
+ex79: ex79.o   chkopts
+	-${CLINKER} -o ex79 ex79.o  ${PETSC_SYS_LIB}
+	${RM} -f ex79.o
+
+ex79f90: ex79f90.o   chkopts
+	-${FLINKER} -o ex79f90 ex79f90.o  ${PETSC_SYS_LIB}
+	${RM} -f ex79f90.o
+
 #
 # ------------------------------------------------------------------------
 #
@@ -112,6 +121,12 @@ runex5f90:
 	   else echo ${PWD} ; echo "Possible problem with with ex5f90_1, diffs above \n========================================="; fi; \
 	   ${RM} -f ex5f90_1.tmp 
 
+runex79:
+	-@${MPIEXEC} -n 1 ./ex79 -f petsc.yaml > ex79_1.tmp 5>&1; \
+	   if (${DIFF} output/ex79_1.out ex79_1.tmp) then true; \
+	   else echo ${PWD} ; echo "Possible problem with with ex5_1, diffs above \n========================================="; fi; \
+	   ${RM} -f ex79_1.tmp 
+
 runex6:
 	-@${MPIEXEC} -n 1 ./ex6 
 
diff -r 93f374d090c4 src/sys/examples/tutorials/output/ex79_1.out
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/sys/examples/tutorials/output/ex79_1.out	Mon Jul 30 15:35:58 2012 -0500
@@ -0,0 +1,47 @@
+#PETSc Option Table entries:
+-a0img_url /finex/html/img/
+-a0title Finex
+-a1img_url /finex/html/img/
+-a1title Finex
+-blabla 1
+-cs0001_force 0.
+-cs0010_force 0.
+-cs0010_hookeslaw 1,2,3,4,5,6
+-cs0020_force 0.
+-f petsc.yaml
+-oula oulala
+-prefix ../TestMeshes/SquareNG-tri3
+-temp_KSP_monitor
+-temp_KSP_type cg
+-temp_snes_type ksponly
+-verbose 1
+-vs0010_temp 0.
+-vs0010_tempBC 1
+-vs0020_temp 1.
+-vs0020_tempBC 1
+-vs0030_temp 1.
+-vs0030_tempBC 1
+#End of PETSc Option Table entries
+WARNING! There are options you set that were not used!
+WARNING! could be spelling mistake, etc!
+Option left: name:-a0img_url value: /finex/html/img/
+Option left: name:-a0title value: Finex
+Option left: name:-a1img_url value: /finex/html/img/
+Option left: name:-a1title value: Finex
+Option left: name:-blabla value: 1
+Option left: name:-cs0001_force value: 0.
+Option left: name:-cs0010_force value: 0.
+Option left: name:-cs0010_hookeslaw value: 1,2,3,4,5,6
+Option left: name:-cs0020_force value: 0.
+Option left: name:-oula value: oulala
+Option left: name:-prefix value: ../TestMeshes/SquareNG-tri3
+Option left: name:-temp_KSP_monitor no value 
+Option left: name:-temp_KSP_type value: cg
+Option left: name:-temp_snes_type value: ksponly
+Option left: name:-verbose value: 1
+Option left: name:-vs0010_temp value: 0.
+Option left: name:-vs0010_tempBC value: 1
+Option left: name:-vs0020_temp value: 1.
+Option left: name:-vs0020_tempBC value: 1
+Option left: name:-vs0030_temp value: 1.
+Option left: name:-vs0030_tempBC value: 1
diff -r 93f374d090c4 src/sys/examples/tutorials/petsc.yaml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/sys/examples/tutorials/petsc.yaml	Mon Jul 30 15:35:58 2012 -0500
@@ -0,0 +1,39 @@
+oula: oulala
+blabla: 1
+prefix: ../TestMeshes/SquareNG-tri3
+verbose: 1
+a1title   : Finex 2011
+a1img_url : /finex/html/img/
+
+vs0010: &clamped {tempBC: 1, temp:   0. }
+
+a0title   : Finex 2011
+a0img_url : /finex/html/img/
+
+vs0020:
+    tempBC: 1
+    temp:   1.
+#vs0040: *clamped
+cs0001:
+    force:  0.
+cs0010:
+    force:  0.
+    hookeslaw: 1,2,3,4,5,6
+cs0020:
+    force:  0.
+    #hookeslaw:
+    #  - 1
+    #  - 2
+    #  - 3
+    #  - 4
+    #  - 5
+    #  - 6
+temp:
+    snes:
+        type: ksponly
+    KSP:
+        type: cg
+        monitor:
+vs0030:
+    tempBC: 1
+    temp:   1.
diff -r 93f374d090c4 src/sys/yaml/ftn-custom/makefile
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/sys/yaml/ftn-custom/makefile	Mon Jul 30 15:35:58 2012 -0500
@@ -0,0 +1,16 @@
+
+#requiresdefine   'PETSC_HAVE_FORTRAN'
+ALL: lib
+CFLAGS   =
+FFLAGS   =
+SOURCEC  = zyamlimplsf.c
+OBJSC    = ${SOURCEC:.c=.o}
+SOURCEF  =
+SOURCEH  =
+DIRS     =
+LIBBASE  = libpetscsys
+LOCDIR   = src/sys/yaml/ftn-custom/
+
+include ${PETSC_DIR}/conf/variables
+include ${PETSC_DIR}/conf/rules
+include ${PETSC_DIR}/conf/test
diff -r 93f374d090c4 src/sys/yaml/ftn-custom/zyamlimplsf.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/sys/yaml/ftn-custom/zyamlimplsf.c	Mon Jul 30 15:35:58 2012 -0500
@@ -0,0 +1,26 @@
+/*
+  This file contains Fortran stubs for Options routines. 
+  These are not generated automatically since they require passing strings
+  between Fortran and C.
+*/
+
+#include <petsc-private/fortranimpl.h> 
+
+#ifdef PETSC_HAVE_FORTRAN_CAPS
+#define petscoptionsinsertfile_yaml_            PETSCOPTIONSINSERTFILE_YAML
+#elif !defined(PETSC_HAVE_FORTRAN_UNDERSCORE)
+#define petscoptionsinsertfile_yaml_            petscoptionsinsertfile_yaml
+#endif
+
+EXTERN_C_BEGIN
+
+void PETSC_STDCALL petscoptionsinsertfile_yaml_(MPI_Fint *comm,CHAR file PETSC_MIXED_LEN(len),PetscBool  *require,PetscErrorCode *ierr PETSC_END_LEN(len))
+{
+  char *c1;
+
+  FIXCHAR(file,len,c1);
+  *ierr = PetscOptionsInsertFile_YAML(MPI_Comm_f2c(*comm),c1,*require);
+  FREECHAR(file,c1);
+}
+
+EXTERN_C_END
diff -r 93f374d090c4 src/sys/yaml/makefile
--- a/src/sys/yaml/makefile	Sat Jul 28 11:35:56 2012 -0500
+++ b/src/sys/yaml/makefile	Mon Jul 30 15:35:58 2012 -0500
@@ -2,7 +2,7 @@
 #requirespackage 'PETSC_HAVE_YAML'
 
 ALL: lib
-SOURCEH   = yamlimpls.h
+SOURCEH   = 
 SOURCEC   = yamlimpls.c
 OBJSC     = yamlimpls.o
 DIRS      =
diff -r 93f374d090c4 src/sys/yaml/yamlimpls.c
--- a/src/sys/yaml/yamlimpls.c	Sat Jul 28 11:35:56 2012 -0500
+++ b/src/sys/yaml/yamlimpls.c	Mon Jul 30 15:35:58 2012 -0500
@@ -1,780 +1,131 @@
-#include "yamlimpls.h"
+#include <petscsys.h>        /*I  "petscsys.h"   I*/
+#include <yaml.h>
 
-void options_list_delete(options_list_t *options_list) {
-  int i, j;
+enum storage_flags {VAR,VAL,SEQ};     /* "Store as" switch */
 
-  for(i=0; i<(*options_list).count; i++)
-  {
-    for(j=0; j<(*options_list).options[i].arguments.count; j++) {
-      if((*options_list).options[i].arguments.args[j]) {
-        free((*options_list).options[i].arguments.args[j]);
+#undef __FUNCT__
+#define __FUNCT__ "PetscParseLayerYAML"
+PetscErrorCode PetscParseLayerYAML(yaml_parser_t *parser,int *lvl)
+{
+  yaml_event_t    event;
+  int             storage = VAR; /* mapping cannot start with VAL definition w/o VAR key */
+  char            key[PETSC_MAX_PATH_LEN],option[PETSC_MAX_PATH_LEN],prefix[PETSC_MAX_PATH_LEN];
+  PetscBool       down = PETSC_FALSE;
+  PetscErrorCode  ierr;
+
+  PetscFunctionBegin;
+  ierr = PetscSNPrintf(option,PETSC_MAX_PATH_LEN,"%s"," ");CHKERRQ(ierr);
+  while (1) {
+    yaml_parser_parse(parser,&event);
+    /* Parse value either as a new leaf in the mapping */
+    /*  or as a leaf value (one of them, in case it's a sequence) */
+    if (event.type == YAML_SCALAR_EVENT) {
+      if (storage) {
+        ierr = PetscSNPrintf(option,PETSC_MAX_PATH_LEN,"-%s %s",key,(char *)event.data.scalar.value);CHKERRQ(ierr);
+        ierr = PetscOptionsInsertString(option);CHKERRQ(ierr);
+      } else {
+        ierr = PetscStrncpy(key,(char *)event.data.scalar.value,event.data.scalar.length+1);CHKERRQ(ierr);
       }
-    }
-    if((*options_list).options[i].arguments.args) {
-      free((*options_list).options[i].arguments.args);
-    }
-    if((*options_list).options[i].name) {
-      free((*options_list).options[i].name);
-    }
-    if((*options_list).options[i].group) {
-      free((*options_list).options[i].group);
-    }
-  }
-  if((*options_list).options) {
-    free((*options_list).options);
-  }
-}
-
-int options_list_populate_yaml(char *str, options_list_t *options_list) {
-  yaml_parser_t parser;
-  yaml_event_t event, *events=0;
-  int i, j, k, ii; /* generic counters */
-  int alias_count, events_length, sequence_stack, mapping_stack, mapping_end_index;; /* named counters */
-  alias_list_t list;
-  grouping_stack_t grouping_stack;
-  const int MAX_NESTED_GROUPS = 10;
-  /* This can be edited later as needed, this is for memory allocation purposes for the grouping_stack */
-
-  /* Initialize objects and check for errors. */
-  if (!yaml_parser_initialize(&parser)) {
-    fprintf(stderr, "Failed to initialize parser. (%s:%d)\n", __FILE__, __LINE__-1);
-    return 0;
-  }
-  yaml_parser_set_input_string(&parser, (unsigned char*) str, strlen(str));
-
-  /* Counting things for memory allocation purposes */
-  if(!yaml_parser_parse(&parser, &event)) {
-    fprintf(stderr, "Parser error. (%s:%d)", __FILE__, __LINE__-1);
-    return 0;
-  }
-  i=0;
-  while(event.type != YAML_STREAM_END_EVENT) {
-    if(event.type == YAML_DOCUMENT_START_EVENT) {
-      yaml_event_delete(&event);
-      if(!yaml_parser_parse(&parser, &event)) {
-        fprintf(stderr, "Parser error. (%s:%d)", __FILE__, __LINE__-1);
-        return 0;
+      storage ^= VAL;           /* Flip VAR/VAL switch for the next event */
+    } else if (event.type == YAML_SEQUENCE_START_EVENT) {
+      /* Sequence - all the following scalars will be appended to the last_leaf */
+      storage = SEQ;
+      SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SUP ,"Sequences not supported");
+    } else if (event.type == YAML_SEQUENCE_END_EVENT) {
+      storage = VAR;
+    } else if (event.type == YAML_MAPPING_START_EVENT) {
+      ierr = PetscSNPrintf(prefix,PETSC_MAX_PATH_LEN,"%s_",key);CHKERRQ(ierr);
+      if (*lvl > 0) {
+        ierr = PetscOptionsPrefixPush(prefix);CHKERRQ(ierr);
       }
-      if(event.type == YAML_MAPPING_START_EVENT) {
-        yaml_event_delete(&event);
-        if(!yaml_parser_parse(&parser, &event)) {
-          fprintf(stderr, "Parser error. (%s:%d)", __FILE__, __LINE__-1);
-          return 0;
-        }
-        if(event.type == YAML_SCALAR_EVENT) {
-          if(strcmp((char*) event.data.scalar.value, "Options") == 0
-          || strcmp((char*) event.data.scalar.value, "options") == 0) {
-            i=3;alias_count=0;
-            while(event.type != YAML_DOCUMENT_END_EVENT) {
-              yaml_event_delete(&event);
-              if(!yaml_parser_parse(&parser, &event)) {
-                fprintf(stderr, "Parser error. (%s:%d)", __FILE__, __LINE__-1);
-                return 0;
-              }
-              i++;
-            }
-          }
-        }
+      (*lvl)++;
+      ierr = PetscParseLayerYAML(parser,lvl);CHKERRQ(ierr);
+      (*lvl)--;
+      if (*lvl > 0) {
+        ierr = PetscOptionsPrefixPop();CHKERRQ(ierr);
       }
-    }
-    yaml_event_delete(&event);
-    if(!yaml_parser_parse(&parser, &event)) {
-      fprintf(stderr, "Parser error. (%s:%d)", __FILE__, __LINE__-1);
-      return 0;
-    }
-  }
-  yaml_event_delete(&event);
-  yaml_parser_delete(&parser);
-
-  /* Populating the alias list. */
-  if(!alias_list_populate_yaml(str, &list)) {
-    fprintf(stderr, "error alias_list_populate_yaml (%s:%d)", __FILE__, __LINE__-1);
-    return 0;
-  }
-
-  /* Allocating memory based on counts from above */
-  events = (yaml_event_t*) calloc((i+1)*4, sizeof(yaml_event_t));
-  /* Multiplied by four because I am not counting the alias events this needs to be worked on later */
-  /* We could overallocate by a lot and realloc once we get the actual number of events in the array later */
-
-  /* Time to load the events to an array so I can better play with them */
-  yaml_parser_initialize(&parser);
-  yaml_parser_set_input_string(&parser, (unsigned char*) str, strlen(str));
-  if(!yaml_parser_parse(&parser, &event)) {
-    fprintf(stderr, "Parser error. (%s:%d)\n", __FILE__, __LINE__-1);
-    return 0;
-  }
-  while(event.type != YAML_STREAM_END_EVENT) {
-    i=0;j=0;sequence_stack=0;
-    if(event.type == YAML_DOCUMENT_START_EVENT) {
-      if(!yaml_event_initialize(&events[i], &event)) {
-        fprintf(stderr, "error yaml_event_initialize (%s:%d)\n",__FILE__,__LINE__-1);
-        return 0;
-      }
-      yaml_event_delete(&event);
-      if(!yaml_parser_parse(&parser, &event)) {
-        fprintf(stderr, "Parser error. (%s:%d)", __FILE__, __LINE__-1);
-        return 0;
-      }
-      i++;
-      if(event.type == YAML_MAPPING_START_EVENT) {
-        if(!yaml_event_initialize(&events[i], &event)) {
-          fprintf(stderr, "error, yamL_event_initialize (%s:%d)\n", __FILE__, __LINE__);
-          return 0;
-        }
-        yaml_event_delete(&event);
-        if(!yaml_parser_parse(&parser, &event)) {
-          fprintf(stderr, "Parser error. (%s:%d)\n", __FILE__, __LINE__-1);
-          return 0;
-        }
-        i++;
-        if(event.type == YAML_SCALAR_EVENT) {
-          if(!yaml_event_initialize(&events[i], &event)) {
-            fprintf(stderr, "error yaml_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-            return 0;
-          }
-          i++;
-          if(strcmp((char*) event.data.scalar.value, "options") == 0
-          || strcmp((char*) event.data.scalar.value, "Options") == 0) {
-            yaml_event_delete(&event);
-            if(!yaml_parser_parse(&parser, &event)) {
-              fprintf(stderr, "Parser error. (%s:%d)\n", __FILE__, __LINE__-1);
-              return 0;
-            }
-            while(event.type != YAML_DOCUMENT_END_EVENT) {
-              switch(event.type) {
-                case YAML_ALIAS_EVENT:
-                  /* Copy all of the alias event info from the alias list */
-                  for(j=0; j<list.count; j++) {
-                    if(strcmp(list.list[j].alias, (char*) event.data.alias.anchor) == 0) {
-                      if(!yaml_event_initialize(&events[i], &list.list[j].event)) {
-                        fprintf(stderr, "error yaml_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-                        return 0;
-                      }
-                      i++;
-                    }
-                  }
-                  break;
-                default:
-                  yaml_event_initialize(&events[i], &event);
-                  i++;
-                  break;
-              }
-              yaml_event_delete(&event);
-              if(!yaml_parser_parse(&parser, &event)) {
-                fprintf(stderr, "Parser error. (%s:%d)\n", __FILE__, __LINE__-1);
-                return 0;
-              }
-              if(event.type == YAML_DOCUMENT_END_EVENT) {
-                if(!yaml_event_initialize(&events[i], &event)) {
-                  fprintf(stderr, "error yaml_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-                  return 0;
-                }
-                i++;
-              }
-            }
-            events_length = i;
-            break;
-          } else {
-            for(i--; i>=0; i--) {
-              yaml_event_delete(&events[i]);
-            }
-          }
-        } else {
-          for(i--; i>=0; i--) {
-            yaml_event_delete(&events[i]);
-          }
-        }
-      } else {
-        for(i--; i>=0; i--) {
-          yaml_event_delete(&events[i]);
-        }
-      }
-    }
-    yaml_event_delete(&event);
-    if(!yaml_parser_parse(&parser, &event)) {
-      fprintf(stderr, "Parser error. (%s:%d)", __FILE__, __LINE__-1);
-      return 0;
-    }
-  }
-  yaml_event_delete(&event);
-  yaml_parser_delete(&parser);
-  alias_list_delete(&list);
-
-  /* Making sure the last block of code ran properly and my config file was written properly */
-  if(events[0].type != YAML_DOCUMENT_START_EVENT
-  || events[1].type != YAML_MAPPING_START_EVENT
-  || events[2].type != YAML_SCALAR_EVENT
-  ||(strcmp((char*) events[2].data.scalar.value, "options") != 0
-  && strcmp((char*) events[2].data.scalar.value, "Options") != 0)
-  || events[3].type != YAML_SEQUENCE_START_EVENT) {
-    fprintf(stderr, "Events did not load properly. (%s:%d)\n", __FILE__, __LINE__);
-    return 0;
-  }
-  for(i=0; i<events_length; i++) {
-    if(events[i].type == YAML_NO_EVENT) {
-      fprintf(stderr, "Events did not load properly. (%s:%d)\n", __FILE__, __LINE__);
-      return 0;
-    }
-  }
-
-  /* Getting the number of options */
-  j=0;
-  for(i=0; i<events_length; i++) {
-    if(events[i].type == YAML_MAPPING_START_EVENT
-    && events[i+1].type == YAML_SCALAR_EVENT
-    &&(events[i+2].type == YAML_SCALAR_EVENT
-    ||(events[i+2].type == YAML_SEQUENCE_START_EVENT
-    && events[i+3].type == YAML_SCALAR_EVENT))) {
-      j++;
-    }
-  }
-  (*options_list).count = j;
-
-  /* Allocating memory for the options_list options */
-  (*options_list).options = (option_t*) calloc((*options_list).count+30, sizeof(option_t));
-
-  /* Time to populate the options_list */
-  /* Start out by putting a fork in the garbage disposal */
-  /* Set up the grouping stack before use */
-  grouping_stack.count = 0;
-  grouping_stack.groups = (grouping_stack_group_t*) calloc(MAX_NESTED_GROUPS, sizeof(grouping_stack_group_t));
-  for(i=0; i<MAX_NESTED_GROUPS; i++) {
-    grouping_stack.groups[i].name = 0;
-    grouping_stack.groups[i].start = 0;
-    grouping_stack.groups[i].end = 0;
-  }
-  grouping_stack.groups[0].name = (char*) calloc(8, sizeof(char));
-  strcpy(grouping_stack.groups[0].name, "default");
-  grouping_stack.groups[0].start = 0;
-  grouping_stack.groups[0].end = 0;
-  grouping_stack.count = 1;
-
-  j=0; mapping_end_index = 0;
-  for(i=3; i<events_length; i++) {
-    if(grouping_stack.groups[grouping_stack.count-1].end == i) {
-      if(grouping_stack.groups[grouping_stack.count-1].name) {
-        free(grouping_stack.groups[grouping_stack.count-1].name);
-        grouping_stack.groups[grouping_stack.count-1].name = 0;
-      }
-      grouping_stack.groups[grouping_stack.count-1].end = 0;
-      grouping_stack.groups[grouping_stack.count-1].start = 0;
-      grouping_stack.count--;
-      if(grouping_stack.count == 0) {
-        grouping_stack.count = 1;
-        grouping_stack.groups[0].name = (char*) calloc(8, sizeof(char));
-        strcpy(grouping_stack.groups[0].name, "default");
-        grouping_stack.groups[0].start = 0;
-        grouping_stack.groups[0].end = 0;
-      }
-    }
-    if(events[i].type == YAML_MAPPING_START_EVENT
-    && events[i+1].type == YAML_SCALAR_EVENT) {
-      if(events[i+2].type == YAML_SCALAR_EVENT
-      && events[i+3].type == YAML_MAPPING_END_EVENT) {
-        /* We have an option with only one arg */
-        ii=0;
-        for(k=0; k<grouping_stack.count; k++) {
-          if(grouping_stack.groups[k].name) {
-            ii+=strlen(grouping_stack.groups[k].name);
-          }
-        }
-        (*options_list).options[j].name = (char*) calloc(events[i+1].data.scalar.length+1, sizeof(char));
-        strcpy((*options_list).options[j].name, (char*)events[i+1].data.scalar.value);
-        (*options_list).options[j].group = (char*) calloc(ii + grouping_stack.count, sizeof(char));
-        strcpy((*options_list).options[j].group, grouping_stack.groups[0].name);
-        for(k=1; k<grouping_stack.count; k++) {
-          strcat((*options_list).options[j].group, "_");
-          strcat((*options_list).options[j].group, grouping_stack.groups[k].name);
-        }
-        (*options_list).options[j].arguments.count = 1;
-        (*options_list).options[j].arguments.args = (char**) calloc(
-        (*options_list).options[j].arguments.count+1, sizeof(char*));
-        (*options_list).options[j].arguments.args[0] = (char*) calloc(
-        events[i+2].data.scalar.length+1, sizeof(char));
-        strcpy((*options_list).options[j].arguments.args[0], (char*) events[i+2].data.scalar.value);
-        j++;i+=2;
-      } else if(events[i+2].type == YAML_SEQUENCE_START_EVENT) {
-        if(events[i+3].type == YAML_SCALAR_EVENT) {
-          /* We have an option that has a sequence of args */
-          /* First lets do what we can before performing a count of the args */
-          ii=0;
-          for(k=0; k<grouping_stack.count; k++) {
-            if(grouping_stack.groups[k].name) {
-              ii+=strlen(grouping_stack.groups[k].name);
-            }
-          }
-          (*options_list).options[j].name = (char*) calloc(events[i+1].data.scalar.length+1, sizeof(char));
-          strcpy((*options_list).options[j].name, (char*) events[i+1].data.scalar.value);
-          (*options_list).options[j].group = (char*) calloc(ii + grouping_stack.count, sizeof(char));
-          strcpy((*options_list).options[j].group, grouping_stack.groups[0].name);
-          for(k=1; k<grouping_stack.count; k++) {
-            strcat((*options_list).options[j].group, "_");
-            strcat((*options_list).options[j].group, grouping_stack.groups[k].name);
-          }
-          k=i+2+1;
-          /* 2+1 for clear thought.  i+2 is the first sequence start event, so I will start at i+2+1 */
-          sequence_stack=1;
-          (*options_list).options[j].arguments.count = 0;
-          while(sequence_stack != 0) {
-            switch(events[k].type) {
-              case YAML_SEQUENCE_START_EVENT:
-                sequence_stack++;
-                break;
-              case YAML_SEQUENCE_END_EVENT:
-                sequence_stack--;
-                break;
-              case YAML_SCALAR_EVENT:
-                if(sequence_stack == 1) {
-                  (*options_list).options[j].arguments.count++;
-                }
-                break;
-              default: break;
-            }
-            k++;
-          }
-          (*options_list).options[j].arguments.args = (char**) calloc(
-          (*options_list).options[j].arguments.count+1, sizeof(char*));
-          for(ii=i+2+1; ii < k; ii++) {
-            if(events[ii].type == YAML_SCALAR_EVENT) {
-              (*options_list).options[j].arguments.args[ii-i-2-1] = (char*) calloc(
-              events[ii].data.scalar.length+1, sizeof(char));
-              strcpy((*options_list).options[j].arguments.args[ii-i-2-1],
-              (char*) events[ii].data.scalar.value);
-            }
-          }
-          j++;
-        } else if(events[i+3].type == YAML_MAPPING_START_EVENT) {
-          /* We have a group of options coming up. */
-          if(grouping_stack.count == 1 && strcmp(grouping_stack.groups[0].name, "default") == 0) {
-            grouping_stack.count--;
-          }
-          if(grouping_stack.groups[grouping_stack.count].name) {
-            free(grouping_stack.groups[grouping_stack.count].name);
-            grouping_stack.groups[grouping_stack.count].name = 0;
-          }
-          grouping_stack.groups[grouping_stack.count].name = (char*) calloc(
-          events[i+1].data.scalar.length+1, sizeof(char));
-          strcpy(grouping_stack.groups[grouping_stack.count].name, (char*) events[i+1].data.scalar.value);
-          grouping_stack.groups[grouping_stack.count].start = i+3;
-          k=i+1;
-          mapping_stack=1;
-          while(mapping_stack!=0) {
-            switch(events[k].type) {
-              case YAML_MAPPING_START_EVENT:
-                mapping_stack++;
-                break;
-              case YAML_MAPPING_END_EVENT:
-                mapping_stack--;
-                break;
-              default: break;
-            }
-            k++;
-          }
-          mapping_end_index = k-1;
-          grouping_stack.groups[grouping_stack.count].end = k-1;
-          grouping_stack.count++;
-          i+=2;
-        }
-      }
-    }
-  }
-
-  /* Cleanup */
-  for(i=0; i<MAX_NESTED_GROUPS; i++) {
-    if(grouping_stack.groups[i].name) free(grouping_stack.groups[i].name);
-  }
-  if(grouping_stack.groups) free(grouping_stack.groups);
-  for(i=0; i<events_length; i++) {
-    yaml_event_delete(&events[i]);
-  }
-  if(events) free(events);
-
-  return 1;
-}
-
-int yaml_event_initialize(yaml_event_t *out, yaml_event_t *in) {
-  switch((*in).type) {
-    case YAML_STREAM_START_EVENT:
-      if(!yaml_stream_start_event_initialize(&(*out), (*in).data.stream_start.encoding)) {
-        fprintf(stderr, "error yaml_stream_start_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
+      storage ^= VAL;           /* Flip VAR/VAL, w/o touching SEQ */
+    } else if (event.type == YAML_MAPPING_END_EVENT || event.type == YAML_STREAM_END_EVENT) {
       break;
-    case YAML_STREAM_END_EVENT:
-      if(!yaml_stream_end_event_initialize(&(*out))) {
-        fprintf(stderr, "error yaml_stream_end_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
-      break;
-    case YAML_DOCUMENT_START_EVENT:
-      if(!yaml_document_start_event_initialize(&(*out), (*in).data.document_start.version_directive,
-      (*in).data.document_start.tag_directives.start, (*in).data.document_start.tag_directives.end,
-      (*in).data.document_start.implicit)) {
-        fprintf(stderr, "error yaml_document_start_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
-      break;
-    case YAML_DOCUMENT_END_EVENT:
-      if(!yaml_document_end_event_initialize(&(*out), (*in).data.document_end.implicit)) {
-        fprintf(stderr, "error yaml_document_end_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
-      break;
-    case YAML_ALIAS_EVENT:
-      if(!yaml_alias_event_initialize(&(*out), (*in).data.alias.anchor)) {
-        fprintf(stderr, "error yaml_alias_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
-      break;
-    case YAML_SCALAR_EVENT:
-      if(!yaml_scalar_event_initialize(&(*out), (*in).data.scalar.anchor,
-      (*in).data.scalar.tag, (*in).data.scalar.value, (*in).data.scalar.length,
-      (*in).data.scalar.plain_implicit, (*in).data.scalar.quoted_implicit,
-      (*in).data.scalar.style)) {
-        fprintf(stderr, "error yaml_scalar_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
-      break;
-    case YAML_SEQUENCE_START_EVENT:
-      if(!yaml_sequence_start_event_initialize(&(*out), (*in).data.sequence_start.anchor,
-      (*in).data.sequence_start.tag, (*in).data.sequence_start.implicit,
-      (*in).data.sequence_start.style)) {
-        fprintf(stderr, "error yaml_sequence_start_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
-      break;
-    case YAML_SEQUENCE_END_EVENT:
-      if(!yaml_sequence_end_event_initialize(&(*out))) {
-        fprintf(stderr, "error yaml_sequence_end_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
-      break;
-    case YAML_MAPPING_START_EVENT:
-      if(!yaml_mapping_start_event_initialize(&(*out), (*in).data.mapping_start.anchor,
-      (*in).data.mapping_start.tag, (*in).data.mapping_start.implicit,
-      (*in).data.mapping_start.style)) {
-        fprintf(stderr, "error yaml_mapping_start_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
-      break;
-    case YAML_MAPPING_END_EVENT:
-      if(!yaml_mapping_end_event_initialize(&(*out))) {
-        fprintf(stderr, "error yaml_mapping_end_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-        return 0;
-      }
-      break;
-    default:
-      fprintf(stderr, "unexpected event (%s:%d)\n", __FILE__, __LINE__);
-      return 0;
-      break;
-  }
-
-  return 1;
-}
-
-int alias_list_populate_yaml(char *str, alias_list_t *list) {
-  yaml_parser_t parser;
-  yaml_event_t event, *events=0;
-  int i, j, k, stacknumber, events_length;
-
-  if(!yaml_parser_initialize(&parser)) {
-    fprintf(stderr, "error initializing parser (%s:%d)\n", __FILE__, __LINE__-1);
-    return 0;
-  }
-  yaml_parser_set_input_string(&parser, (unsigned char*) str, strlen(str));
-
-  /* Getting count to allocate memory for the events array. */
-  i=0;
-  if(!yaml_parser_parse(&parser, &event)) {
-    fprintf(stderr, "error yaml_parser_parse (%s:%d)\n", __FILE__, __LINE__-1);
-    return 0;
-  }
-  while(event.type != YAML_STREAM_END_EVENT) {
-    i++;
-    yaml_event_delete(&event);
-    if(!yaml_parser_parse(&parser, &event)) {
-      fprintf(stderr, "error yaml_parser_parse (%s:%d)\n", __FILE__, __LINE__-1);
-      return 0;
-    }
-  }
-  events_length = i;
-  yaml_event_delete(&event);
-  yaml_parser_delete(&parser);
-
-  /* Allocate memory for the events array */
-  events = (yaml_event_t*) calloc(events_length+1, sizeof(yaml_event_t));
-
-  /* Now to copy everything to the events array */
-  yaml_parser_initialize(&parser);
-  yaml_parser_set_input_string(&parser, (unsigned char*) str, strlen(str));
-  for(i=0; i<events_length; i++) {
-    if(!yaml_parser_parse(&parser, &event)) {
-      fprintf(stderr, "error yaml_parser_parse (%s:%d)\n", __FILE__, __LINE__-1);
-      return 0;
-    }
-    if(!yaml_event_initialize(&events[i], &event)) {
-      fprintf(stderr, "error yaml_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-      return 0;
     }
     yaml_event_delete(&event);
   }
-  yaml_parser_delete(&parser);
-
-  /* Lets count so I can later allocate memory for the alias list */
-  stacknumber = 0;
-  (*list).count = 0;
-  for(i=0; i<events_length; i++) {
-    switch(events[i].type) {
-      case YAML_SCALAR_EVENT:
-        if(events[i].data.scalar.anchor != NULL) {
-          (*list).count++;
-        }
-        break;
-      case YAML_SEQUENCE_START_EVENT:
-        if(events[i].data.sequence_start.anchor != NULL) {
-          (*list).count++;
-          stacknumber = 1;
-          j=i;j++;
-          while(stacknumber != 0) {
-            switch(events[j].type) {
-              case YAML_SEQUENCE_START_EVENT:
-                stacknumber++;
-                break;
-              case YAML_SEQUENCE_END_EVENT:
-                stacknumber--;
-                break;
-              default: break;
-            }
-            j++;
-            (*list).count++;
-          }
-        }
-        break;
-      case YAML_MAPPING_START_EVENT:
-        if(events[i].data.mapping_start.anchor != NULL) {
-          (*list).count++;
-          stacknumber = 1;
-          j=i;j++;
-          while(stacknumber != 0) {
-            switch(events[j].type) {
-              case YAML_MAPPING_START_EVENT:
-                stacknumber++;
-                break;
-              case YAML_MAPPING_END_EVENT:
-                stacknumber--;
-                break;
-              default: break;
-            }
-            j++;
-            (*list).count++;
-          }
-        }
-        break;
-      default: break;
-    }
-  }
-
-  /* Lets allocate memory for the alias list */
-  (*list).list = (alias_key_value_t*) calloc((*list).count+1, sizeof(alias_key_value_t));
-
-  /* Now to run through the same algorithm to populate the list */
-  j=0;
-  for(i=0; i<events_length; i++) {
-    switch(events[i].type) {
-      case YAML_SCALAR_EVENT:
-        if(events[i].data.scalar.anchor != NULL) {
-          (*list).list[j].alias = (char*) calloc(
-          strlen((char*) events[i].data.scalar.anchor)+1, sizeof(char));
-          strcpy((*list).list[j].alias, (char*) events[i].data.scalar.anchor);
-          if(!yaml_event_initialize(&(*list).list[j].event, &events[i])) {
-            fprintf(stderr, "error yaml_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-            return 0;
-          }
-          j++;
-        }
-        break;
-      case YAML_SEQUENCE_START_EVENT:
-        if(events[i].data.sequence_start.anchor != NULL) {
-          (*list).list[j].alias = (char*) calloc(
-          strlen((char*) events[i].data.sequence_start.anchor)+1, sizeof(char));
-          strcpy((*list).list[j].alias, (char*) events[i].data.sequence_start.anchor);
-          if(!yaml_event_initialize(&(*list).list[j].event, &events[i])) {
-            fprintf(stderr, "error yaml_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-            return 0;
-          }
-          stacknumber = 1;
-          j++;
-          k=i;k++;
-          while(stacknumber != 0) {
-            switch(events[k].type) {
-              case YAML_SEQUENCE_START_EVENT:
-                stacknumber++;
-                break;
-              case YAML_SEQUENCE_END_EVENT:
-                stacknumber--;
-                break;
-              default: break;
-            }
-            (*list).list[j].alias = (char*) calloc(strlen((*list).list[j-1].alias)+1, sizeof(char));
-            strcpy((*list).list[j].alias, (*list).list[j-1].alias);
-            if(!yaml_event_initialize(&(*list).list[j].event, &events[k])) {
-              fprintf(stderr, "error yaml_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-              return 0;
-            }
-            j++;k++;
-          }
-        }
-        break;
-      case YAML_MAPPING_START_EVENT:
-        if(events[i].data.mapping_start.anchor != NULL) {
-          (*list).list[j].alias = (char*) calloc(
-          strlen((char*) events[i].data.mapping_start.anchor)+1, sizeof(char));
-          strcpy((*list).list[j].alias, (char*) events[i].data.mapping_start.anchor);
-          if(!yaml_event_initialize(&(*list).list[j].event, &events[i])) {
-            fprintf(stderr, "error yaml_event_initialize (%s:%d)\n", __FILE__, __LINE__-1);
-            return 0;
-          }
-          stacknumber = 1;
-          j++;
-          k=i;k++;
-          while(stacknumber != 0) {
-            switch(events[k].type) {
-              case YAML_MAPPING_START_EVENT:
-                stacknumber++;
-                break;
-              case YAML_SEQUENCE_END_EVENT:
-                stacknumber--;
-                break;
-              default: break;
-            }
-            (*list).list[j].alias = (char*) calloc(strlen((*list).list[j-1].alias)+1, sizeof(char));
-            strcpy((*list).list[j].alias, (*list).list[j-1].alias);
-            if(!yaml_event_initialize(&(*list).list[j].event, &events[i])) {
-              fprintf(stderr, "error yaml_event_initialize(%s:%d)\n", __FILE__, __LINE__-1);
-              return 0;
-            }
-            j++;k++;
-          }
-        }
-        break;
-      default: break;
-    }
-  }
-
-  /* Cleanup */
-  for(i=0; i<events_length; i++) {
-    yaml_event_delete(&events[i]);
-  }
-  if(events) free(events);
-
-  return 1;
-}
-
-void alias_list_delete(alias_list_t *list) {
-  int i;
-
-  for(i=0; i<(*list).count; i++) {
-    if((*list).list[i].alias) free((*list).list[i].alias);
-    yaml_event_delete(&(*list).list[i].event);
-  }
-  if((*list).list) free((*list).list);
-  (*list).count = 0;
-}
-
-#undef __FUNCT__
-#define __FUNCT__ "file_to_string"
-PetscErrorCode file_to_string(char* filename, char** str) {
-  FILE *fh;
-  char *line;
-  PetscErrorCode ierr;
-
-  PetscFunctionBegin;
-  if((*str) != NULL) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_SYS,"argument: str is not NULL");
-
-  fh = fopen(filename, "r");
-  if(!fh) PetscFunctionReturn(1); /* Return error code , and let calling function decide about the error */
-
-  ierr = PetscMalloc(64000*sizeof(char), &line);CHKERRQ(ierr);
-  ierr = PetscMalloc(128000*sizeof(char), str);CHKERRQ(ierr);
-  /* might change to dynamically allocate this at a later time */
-
-  while(fgets(line, 64000, fh) != NULL) strcat((*str), line);
-
-  ierr = PetscFree(line);CHKERRQ(ierr);
-  if(fh) fclose(fh);
-
   PetscFunctionReturn(0);
 }
 
 #undef __FUNCT__
 #define __FUNCT__ "PetscOptionsInsertFile_YAML"
-PetscErrorCode PetscOptionsInsertFile_YAML(MPI_Comm comm, const char file[], PetscBool require)
+/*C
+  
+  PetscOptionsInsertFile_YAML - Insert a YAML-formatted file in the option database
+  
+  Collective on MPI_Comm
+  
+  Input Parameter:
++   comm - the processes that will share the options (usually PETSC_COMM_WORLD)
+.   file - name of file
+-   require - if PETSC_TRUE will generate an error if the file does not exist
+
+
+  Only a small subset of the YAML standard is implemented. Sequences and alias
+  are NOT supported. 
+  The algorithm recursively parses the yaml file, pushing and popping prefixes
+  and inserting key + values pairs using PetscOptionsInsertString.
+  There is a limit of 128,000 char on the file length.
+  
+  Inspired by  http://stackoverflow.com/a/621451
+
+  Level: developer
+
+.seealso: PetscOptionsSetValue(), PetscOptionsView(), PetscOptionsHasName(), PetscOptionsGetInt(),
+          PetscOptionsGetReal(), PetscOptionsGetString(), PetscOptionsGetIntArray(), PetscOptionsBool(),
+          PetscOptionsName(), PetscOptionsBegin(), PetscOptionsEnd(), PetscOptionsHead(),
+          PetscOptionsStringArray(),PetscOptionsRealArray(), PetscOptionsScalar(),
+          PetscOptionsBoolGroupBegin(), PetscOptionsBoolGroup(), PetscOptionsBoolGroupEnd(),
+          PetscOptionsList(), PetscOptionsEList(), PetscOptionsInsertFile()
+C*/
+extern PetscErrorCode PetscOptionsInsertFile_YAML(MPI_Comm comm,const char file[],PetscBool require)
 {
-  PetscErrorCode ierr, ierr_file;
-  options_list_t options_list;
-  PetscMPIInt    rank,cnt=0;
-  char           *vstring = 0, fname[PETSC_MAX_PATH_LEN], *ostring = 0;
-  size_t         i, len;
-  PetscBool match;
-
+#define PETSC_MAX_YAML_LEN 128000
+  PetscErrorCode ierr;
+  PetscMPIInt    rank;
+  char           fname[PETSC_MAX_PATH_LEN];
+  unsigned char  optionsStr[PETSC_MAX_YAML_LEN];
+  yaml_parser_t  parser;
+  int            lvl=0;
+  FILE          *source;
+  PetscViewer    viewer;
+  PetscInt       offset = 0;
+  int            stat   = 1;
+  
   PetscFunctionBegin;
   ierr = MPI_Comm_rank(comm,&rank);CHKERRQ(ierr);
   if (!rank) {
-    /* Warning: assume a maximum size for all options in a string */
-    ierr = PetscMalloc(128000*sizeof(char),&vstring);CHKERRQ(ierr);
-    vstring[0] = 0;
-    cnt = 0;
+    ierr = PetscFixFilename(file,fname);CHKERRQ(ierr);
+    source = fopen(fname,"r");
+    if (source) {
+      /* Read the content of the YAML file one char at a time*/
+      while ((offset < PETSC_MAX_YAML_LEN) && stat) {
+        stat = fread(&(optionsStr[offset]), sizeof(unsigned char),1,source);
+        offset++;
+      }
+      fclose(source);
+      if (offset == PETSC_MAX_YAML_LEN) {
+        SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_FILE_READ,"YAML option file too long. Split options in multiple files of less than %d chars \n",PETSC_MAX_YAML_LEN);
+      } else {
+        optionsStr[offset] = '\0';
+      }
+    } else if (require) {
+      SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_FILE_OPEN,"Unable to open YAML option file %s\n",fname);
+    }
+  } 
+  ierr = MPI_Bcast(&offset,1,MPI_INT,0,comm);
+  ierr = MPI_Bcast(optionsStr,offset+1,MPI_CHAR,0,comm);
+  
+  yaml_parser_initialize(&parser);
+  yaml_parser_set_input_string(&parser,optionsStr,(size_t) offset-1);
+  ierr = PetscParseLayerYAML(&parser,&lvl);
+  yaml_parser_delete(&parser);
 
-    ierr      = PetscFixFilename(file,fname);CHKERRQ(ierr);
-    ierr_file = file_to_string(fname, &ostring);
-    if (ierr_file && require) SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_USER,"Unable to open YAML Options File %s",fname);
-    if (ierr_file) PetscFunctionReturn(0);
-
-    if (options_list_populate_yaml(ostring,&options_list)) {
-      ierr = PetscInfo1(0,"Read YAML options file %s\n",file);CHKERRQ(ierr);
-      for (i=0;i<options_list.count;i++) {
-        if (options_list.options[i].arguments.count == 1) {
-          ierr = PetscStrcasecmp(options_list.options[i].arguments.args[0], "false", &match);CHKERRQ(ierr);
-          if (!match) {
-            /* The current option has one argument it is not false.  Something will have to be copied */
-            ierr = PetscStrcat(vstring,"-");CHKERRQ(ierr);
-            ierr = PetscStrcasecmp(options_list.options[i].group, "default", &match);CHKERRQ(ierr);
-            if (!match) {
-              /* The current option is not in the default group. The group name and option name needs to be copied. */
-              ierr = PetscStrcat(vstring,options_list.options[i].group);CHKERRQ(ierr);
-              ierr = PetscStrcat(vstring,"_");CHKERRQ(ierr);
-            }
-            ierr = PetscStrcat(vstring,options_list.options[i].name);CHKERRQ(ierr);
-            ierr = PetscStrcat(vstring," ");CHKERRQ(ierr);
-            ierr = PetscStrcasecmp(options_list.options[i].arguments.args[0], "true", &match);CHKERRQ(ierr);
-            if (!match) {
-              /*The argument needs to be copied. */
-              ierr = PetscStrcat(vstring,options_list.options[i].arguments.args[0]);CHKERRQ(ierr);
-              ierr = PetscStrcat(vstring," ");CHKERRQ(ierr);
-            }
-          }
-        } else {
-          SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_ARG_WRONG,"Invalid number of arguments (%s: %s)",options_list.options[i].group,options_list.options[i].name);
-        }
-      }
-      options_list_delete(&options_list);
-      ierr = PetscStrlen(vstring,&len);CHKERRQ(ierr);
-      cnt  = PetscMPIIntCast(len);CHKERRQ(ierr);
-    } else if (require) {
-      SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_USER,"Unable to process YAML Options File %s",fname);
-    }
-  }
-
-  ierr = MPI_Bcast(&cnt,1,MPI_INT,0,comm);CHKERRQ(ierr);
-  if (cnt) {
-    if (rank) {
-      ierr = PetscMalloc((cnt+1)*sizeof(char),&vstring);CHKERRQ(ierr);
-    }
-    ierr = MPI_Bcast(vstring,cnt,MPI_CHAR,0,comm);CHKERRQ(ierr);
-    vstring[cnt] = 0;
-    ierr = PetscOptionsInsertString(vstring);CHKERRQ(ierr);
-  }
-  ierr = PetscFree(vstring);CHKERRQ(ierr);
   PetscFunctionReturn(0);
 }
diff -r 93f374d090c4 src/sys/yaml/yamlimpls.h
--- a/src/sys/yaml/yamlimpls.h	Sat Jul 28 11:35:56 2012 -0500
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,141 +0,0 @@
-#include <petscsys.h>
-#include <yaml.h>
-
-/* The option structure */
-typedef struct option_s {
-  /* The option name */
-  char *name;
-  /* The group the option is in. Defaults to default */
-  char *group;
-  struct {
-    /* The array of strings containing the arguments */
-    char **args;
-    /* The number of arguments in the list */
-    int count;
-  } arguments;
-} option_t;
-
-/* The options_list structure */
-typedef struct options_list_s {
-  /* The array containing the options */
-  option_t *options;
-  /* The length of the options list */
-  int count;
-} options_list_t;
-
-/**
- * This is a generic function to call on the proper function to populate an options list.
- *
- * The application is responsible for freeing any buffers associated with the produced
- * options_list object using the options_list_delete function.
- *
- * @param[in]   filename       A string containing the filename
- * @param[out]  options_list   An empty options_list_t object.
- *
- * returns 1 if the function succeeded, 0 on error.
- */
-int
-options_list_populate(char *filename, options_list_t *options_list);
-
-/**
- * Reads a YAML file from a string and produces an options_list.
- *
- * The application is responsible for freeing any buffers assiciated with the produced
- * options_list object using the options_list_delete function.
- *
- * @param[in]   str            A string containing the YAML file. 
- * @param[out]  options_list   An empty options_list object.
- *
- * returns 1 if the function succeeded, 0 on error.
- */
-int
-options_list_populate_yaml(char *str, options_list_t *options_list);
-
-/**
- * Destroy an options_list
- *
- * @param[in,out]  options_list  An options_list object.
- */
-void
-options_list_delete(options_list_t *options_list);
-
-/**
- * Reads data from a file and copies it to a string.
- *
- * The application is responsible for freeing the str buffer.
- *
- * @param[in]    filename    The name of the file to be read to string.
- * @param[out]   str         The address of a NULL char* object.
- *
- * returns 1 on success, 0 on error.
- */
-PetscErrorCode
-file_to_string(char *filename, char **str);
-
-/* The grouping_stack_group structure */
-typedef struct grouping_stack_group_s {
-  /* The name of the group */
-  char *name;
-  /* The event index the group starts at */
-  int start;
-  /* The event index the group ends at */
-  int end;
-} grouping_stack_group_t;
-
-/* The grouping_stack structure */
-typedef struct grouping_stack_s {
-  /* The array of groups in the stack */
-  grouping_stack_group_t *groups;
-  /* The number of elements in the string array */
-  int count;
-} grouping_stack_t;
-
-/* The alias_key_value structure */
-typedef struct alias_key_value_s {
-  /* The string containing the alias name */
-  char *alias;
-  /* The YAML event corresponding with the name */
-  yaml_event_t event;
-} alias_key_value_t;
-
-/* The alias_list structure */
-typedef struct alias_list_s {
-  /* The length of the list */
-  int count;
-  /* The list itself */
-  alias_key_value_t *list;
-} alias_list_t;
-
-/**
- * Generic copy constructor for a YAML event.
- *
- * @param[out]  out  An uninitialized yaml_event_t object.
- * @param[in]   in   The yaml_event_t object to copy.
- *
- * returns 1 if the function succeeded, 0 on error.
- */
-int
-yaml_event_initialize(yaml_event_t *out, yaml_event_t *in);
-
-/**
- * Populates a list of alias information from parsing a yaml file.
- * This is only called on by the options_list_populate_yaml function.
- *
- * The application is responsible for freeing any buffers associated
- * with the alias_list_t object by use of the alias_list_delete() function.
- *
- * @param[in]   str        A string containing the YAML document to be read.
- * @param[out]  list       An empty alias_list_t object.
- *
- * returns 1 on success.
- */
-int
-alias_list_populate_yaml(char *str, alias_list_t *list);
-
-/**
- * Destroy an alias_list_t object.
- *
- * @param[in,out]   list   An alias_list_t object.
- */
-void
-alias_list_delete(alias_list_t *list);
